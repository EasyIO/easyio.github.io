<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[♪Panama - Mattleo]]></title>
    <url>%2F2018%2F04%2F03%2Fmusic-panama-mattleo%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>音乐π</category>
      </categories>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux目录结构]]></title>
    <url>%2F2018%2F04%2F02%2Flinux-directory-tree%2F</url>
    <content type="text"><![CDATA[可分享的(shareable) 不可分享的(unshareable) 不变的(static) /usr (软件放置处) /etc (配置文件) 不变的(static) /opt (第三方协力软件) /boot (开机与核心档) 可变动的(variable) /var/mail (使用者邮件信箱) /var/run (程序相关) 可变动的(variable) /var/spool/news (新闻组) /var/lock (程序相关) 四种类型 可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录； 不可分享的：自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。 不变的：有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等； 可变动的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。 事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义： / (root, 根目录)：与开机系统有关； /usr (unix software resource)：与软件安装/执行有关； /var (variable)：与系统运作过程有关。 根目录 (/) 的意义与内容根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的,同时根目录也与开机/还原/系统修复等动作有关。由于系统开机时需要特定的开机软件、核心文件、开机所需程序、函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区，因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。因此FHS标准建议：根目录(/)所在分区应该越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。说白了，就是根目录和Windows的C盘一个样。根据以上原因，FHS认为根目录(/)下应该包含如下子目录 目录 应放置档案内容 /bin 系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。 /boot 主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录。 /dev 在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp*, / dev/hd*, /dev/sd*等等 /etc 系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： /etc/init.d/iptables start、/etc/init.d/ iptables stop /etc/xinetd.d/ ：这就是所谓的super daemon管理的各项服务的设定档目录。/etc/X11/ ：与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。 /home 这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： ~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。 /lib 系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)。 /media media是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。 /mnt 如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦。 只是有了/media之后，这个目录就用来暂时挂载用了。 事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要我们了解一下，具体如下： 目录 应放置档案内容 /lost+found 这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found /proc 这个目录本身是一个虚拟文件系统(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等等。呵呵，是虚拟内存吗[guest]？ /sys 这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。 除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分区去。那哪些目录不可与根目录分开呢？有底下这些： /etc：配置文件 /bin：重要执行档 /dev：所需要的装置文件 /lib：执行档所需的函式库与核心所需的模块 /sbin：重要的系统执行文件 /usr 的意义与内容依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)， 如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用喔。/usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据啦。这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些： 目录 应放置档案内容 /usr/X11R6/ 为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。 /usr/bin/ 绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关) /usr/include/ c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。 /usr/lib/ 包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生 /usr/local/ 统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录 /usr/sbin/ 非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon) /usr/share/ 放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件,/usr/share/doc：软件杂项的文件说明,/usr/share/zoneinfo：与时区有关的时区文件 /usr/src/ 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 /var 的意义与内容如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有： 目录 应放置档案内容 /var/cache/ 应用程序本身运作过程中会产生的一些暂存档 /var/lib/ 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去 /var/lock/ 某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用 /var/log/ 非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。 /var/mail/ 放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。 /var/run/ 某些程序或者是服务启动后，会将他们的PID放置在这个目录下 /var/spool/ 这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中。 由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。 目录树(directory tree)在Linux底下，所有的文件与目录都是由根目录开始的。那是所有目录与文件的源头, 然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directory tree), 这个目录树的主要特性有：目录树的启始点为根目录 (/, root)；每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。如果我们将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话，那么目录树架构就如下图所示： 绝对路径与相对路径除了需要特别注意的FHS目录配置外，在文件名部分我们也要特别注意。因为根据档名写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。 这两种文件名/路径的写法依据是这样的：绝对路径：由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；相对路径：相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 http://www.cnblogs.com/home/dmtsai/ 等等。反正开头不是 / 就属于相对路径的写法而你必须要了解，相对路径是以你当前所在路径的相对位置来表示的。举例来说，你目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？命令：12cd /var/log (absolute)cd ../var/log (relative) 因为你在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的，特别注意这两个特殊的目录：. ：代表当前的目录，也可以使用 ./ 来表示；.. ：代表上一层目录，也可以 ../ 来代表。这个 . 与 .. 目录概念是很重要的，你常常会看到 cd .. 或 ./command 之类的指令下达方式， 就是代表上一层与目前所在目录的工作状态。实例1：如何先进入/var/spool/mail/目录，再进入到/var/spool/cron/目录内？命令： cd /var/spool/mail cd ../cron 说明：由于/var/spool/mail与/var/spool/cron是同样在/var/spool/目录中。如此就不需要在由根目录开始写起了。这个相对路径是非常有帮助的，尤其对于某些软件开发商来说。 一般来说，软件开发商会将数据放置到/usr/local/里面的各相对目录。 但如果用户想要安装到不同目录呢？就得要使用相对路径。实例2：网络文件常常提到类似./run.sh之类的数据，这个指令的意义为何？说明：由于指令的执行需要变量的支持，若你的执行文件放置在本目录，并且本目录并非正规的执行文件目录(/bin, /usr/bin等为正规)，此时要执行指令就得要严格指定该执行档。./代表本目录的意思，所以./run.sh代表执行本目录下， 名为run.sh的文件]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie参数简介]]></title>
    <url>%2F2018%2F04%2F01%2Fweb-cookie%2F</url>
    <content type="text"><![CDATA[参数 简介 Domain 设置关联cookie的域名 Expires 通过给定一个过期时间来创建一个持久化cookie httponly 避免cookie被js访问 name cookie名称 path 关联到cookie的路径，默认为 / value 值 secure 用于指定cookie需要通过安全socket曾连接传递]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite组件简介]]></title>
    <url>%2F2018%2F04%2F01%2Fcs-burpsuite%2F</url>
    <content type="text"><![CDATA[组件 简介 Proxy 是一个拦截HTTP/S的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许你拦截，查看，修改在两个方向上的原始数据流 Spider 是一个应用智能感应的网络爬虫，它能完整的枚举应用程序的内容和功能 Scanner 是一个高级的工具，执行后，它能自动地发现web 应用程序的安全漏洞 Intruder 是一个定制的高度可配置的工具，对web应用程序进行自动化攻击，如：枚举标识符，收集有用的数据，以及使用fuzzing 技术探测常规漏洞 Repeater 是一个靠手动操作来补发单独的HTTP 请求，并分析应用程序响应的工具 Sequencer 是一个用来分析那些不可预知的应用程序会话令牌和重要数据项的随机性的工具 Decoder 是一个进行手动执行或对应用程序数据者智能解码编码的工具 Comparer 是一个实用的工具，通常是通过一些相关的请求和响应得到两项数据的一个可视化的“差异”]]></content>
      <categories>
        <category>安全π</category>
      </categories>
      <tags>
        <tag>BurpSuite</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-vim%2F</url>
    <content type="text"><![CDATA[一般模式 : 删除、复制与粘贴类命令123456789101112131415x,X x为向后删除一个字符，X为先前删除一个字符nx(n代表数字) 向后删除n个字符dd 删除当前行D 删除当前行所有字符，试成为空行ndd(n代表数字) 删除光标所在行的向下n列d1G 删除光标所在行到第一行的所有数据dG 删除光标所在行到最后一行的所有数据yy 复制光标所在行y1G 复制光标所在行到第一行的所有数据yG 复制光标所在行到最后一行的所有数据ynj(n代表数字) 复制光标所在行向下n+1行dnj(n代表数字) 删除光标所在行向下n+1行p,P p为复制的数据粘贴在光标的下一行，P为复制的数据粘贴在光标的上一行J 将光标所在行与下一行的数据结合成一行u 恢复前一个动作(undo) 编辑模式123456i,I i为在当前光标所在处插入输入的文字，I为在光标所在行第一个非空字符插入输入的文字a,A a为在当前光标所在处下一个字符插入输入的文字，A为在光标所在行 最后一个字符的下一个字符处插入输入的文字o,O o为在光标所在行的下一行行首开始插入字符，O为在光标所在行的上一行行首开始插入字符r,R r为替换光标所在那一个字符，R为一直替换光标所指的文字，直到退出Esc 退出，回到一般模式 命令模式12345678910111213141516171819202122232425262728293031323334h 光标向左移一个字符j 光标向下移一个字符k 光标向上移一个字符l 光标向右移一个字符Ctrl+f 屏幕向下翻一页Ctrl+b 屏幕向上翻一页Ctrl+d 屏幕向下翻半页Ctrl+u 屏幕向上翻半页+ 光标移动到下一行的第一个非空字符- 光标移动到当前行的第一个非空字符n空格(n代表数字) 光标向当前行向右移动n个字符0(数字0) 光标移动到当前行的第一个字符(可以为空字符,注意与-区分）$ 光标移动到当前行的最后一个字符(可以为空字符,注意与-区分）H 光标移动到当前屏幕最上方的那一行的第一个非空字符M 光标移动到当前屏幕最中间那一行的第一个非空字符L 光标移动到当前屏幕最下方的那一行的第一个非空字符G 光标移动到该文章最后一行的第一个非空字符nG(n代表数字) 光标移动到该文章第n行的第一个非空字符n 光标从当前行向下移动n行的第一个非空字符/word 在光标之后查找word字符串?word 在光标之前查找word字符串:s/word1/word2/g 在光标当前行查找word1，并替换成word2:n1,n2s/word1/word2/g 在第n1行与第n2行之间查找word1，并替换成word2:%s/word1/word2/g 整个文章查找word1，并替换成word2:w 将编辑的数据保存到硬盘文件中:w [filename] 将编辑后的数据保存到硬盘的另一个文件中:r [filename] 在编辑数据时，读入另一个文件中的数据， 即将filename文件中的内容加到光标所在行下一行:wq或:x 保存并退出:q 退出，适用于未修改的文件:q! 强制退出，适用于修改文件后不保存退出:set nu 显示行号:set nonu 取消行号:n1,n2 w [filename] 将n1到n2行的内容保存到名为filename的文件中]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu设置应用在后台运行服务]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-ubuntu-bakcgroup%2F</url>
    <content type="text"><![CDATA[12345678910111213141516# 方法一:$ setsid python xxx.py &gt;log.txt$ ps -aux $ ps -ef |grep run.py$ kill -9 [PID]# 方法二:$ nohup python run.py &gt;log.txt# 将打印内容重定向到/dev/null中，相当于直接丢弃，任何地方都找不到打印的内容$ python your_script.py &gt;&gt; /dev/null # 如果又要查看打印的内容，怎么让它输出(还在运行)？# 将输出重定向到当前目录下的log.txt文件中$ python your_script.py &gt;&gt; log.txt$ cat log.txt # 查看截止目前所有的日志内容$ tail log.txt # 查看截止目前，最后10行日志$ tail -f log.txt # 从最后10行开始滚动输出，准实时刷新$ tail -n 100 -f log.txt # 从最后100行开始滚动输出]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS clean boot]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-centos-clean-boot%2F</url>
    <content type="text"><![CDATA[12345678# 1.使用如下命令查询目前安装在系统里的全部内核（kernel）$ rpm -q kernel# 2.查询当前使用的内核（kernel）版本$ uname -a# 3.删除除当前内核以外所有的内核$ rpm -e '内核版本号'$ rpm -e kernel-2.6.32-358.el6.i686# 4.使用命令df -h 查看/boot分区的使用情况。]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2F2018%2F04%2F01%2Fmaven%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334# 1.创建Maven的普通java项目$ mvn archetype:create -DgroupId=packageName -DartifactId=projectName # 2.创建Maven的Web项目$ mvn archetype:create -DgroupId=packageName -DartifactId= webappName-DarchetypeArtifactId=maven-archetype-webapp # 3.编译源代码： $ mvn compile # 4.编译测试代码：$ mvn test-compile # 5.运行测试：$ mvn test # 6.产生site：$ mvn site # 7.打包：$ mvn package # 8.在本地Repository中安装jar：$ mvn install # 9.清除产生的项目：$ mvn clean # 10.生成eclipse项目：$ mvn eclipse:eclipse # 11.生成idea项目：$ mvn idea:idea # 12.组合使用goal命令，如只打包不测试：$ mvn -Dtest package # 13.编译测试的内容：$ mvn test-compile # 14.只打jar包: $ mvn jar:jar # 15.只测试而不编译，也不测试编译：$ mvn test -skipping compile -skipping test-compile ( -skipping 的灵活运用，当然也可以用于其他组合命令) # 16.清除eclipse的一些系统设置:$ mvn eclipse:clean 1234567# 源更换&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 123456789101112131415161718192021# pom.xml&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; # snapshot 快照 # alpha 内部测试 # beta 公测 # release 稳定 # GA 正式发布&lt;packaging&gt;jar&lt;/packaging&gt; #war zip pom &lt;profile&gt; &lt;id&gt;jdk1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; ​]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker基础命令]]></title>
    <url>%2F2018%2F04%2F01%2Fdocker-command%2F</url>
    <content type="text"><![CDATA[1234567891011121314# 镜像$ docker images # 查看镜像$ docker pull$ docker inspect id # 详细信息$ docker search XXX # 搜索$ docker rmi XXX # 删除$ docker ps -a # 查看所有容器$ docker commit -a 作者 -m提交信息 -p 提交时暂停容器运行$ docker save -o ubuntu_14.04.tar ubuntu:14.04 # 存出镜像$ docker load &lt;ubuntu_14.04.tar # 载入镜像# 容器$ docker create it XXX # 新建容器$ docker run $ docker stop]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu常用命令]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-ubuntu-command%2F</url>
    <content type="text"><![CDATA[文件/文件夹管理12345678910111213$ ls # 列出当前目录文件（不包括隐含文件） $ ls -a # 列出当前目录文件（包括隐含文件） $ ls -l # 列出当前目录下文件的详细信息 $ cd .. # 回当前目录的上一级目录 $ cd - # 回上一次所在的目录 $ cd ~ 或 cd # 回当前用户的宿主目录 $ mk 目录名 # 创建一个目录 $ rmdir 空目录名 # 删除一个空目录 $ rm 文件名 文件名 # 删除一个文件或多个文件 $ rm -rf 非空目录名 # 删除一个非空目录下的一切 $ mv 路经/文件 # /路经/文件移动相对路经下的文件到绝对路经下 $ mv 文件名 新名称 # 在当前目录下改名 $ find 路经 -name “字符串” # 查找路经所在范围内满足字符串匹配的文件和目录 系统管理123456789101112131415161718192021222324252627$ fdisk fdisk -l # 查看系统分区信息 $ fdisk fdisk /dev/sdb # 为一块新的SCSI硬盘进行分区 $ chown chown root /home # 把/home的属主改成root用户 $ chgrp chgrp root /home # 把/home的属组改成root组 $ Useradd # 创建一个新的用户 $ Groupadd 组名 # 创建一个新的组 $ Passwd 用户名 # 为用户创建密码 $ Passwd -d用户名 # 删除用户密码也能登陆 $ Passwd -S用户名 # 查询账号密码 $ Usermod -l 新用户名 老用户名 # 为用户改名 $ Userdel–r 用户名 # 删除用户一切 $ service [servicename] start/stop/restart # 系统服务控制操作 $ /etc/init.d/[servicename] start/stop/restart # 系统服务控制操作 $ uname -a # 查看内核版本 $ cat /etc/issue # 查看ubuntu版本 $ lsusb # 查看usb设备 $ sudo ethtool eth0 # 查看网卡状态 $ cat /proc/cpuinfo # 查看cpu信息 $ lshw # 查看当前硬件信息 $ sudo fdisk -l # 查看磁盘信息 $ df -h # 查看硬盘剩余空间 $ free -m # 查看当前的内存使用情况 $ ps -A # 查看当前有哪些进程 $ kill # 进程号(就是ps -A中的第一列的数字)或者 killall 进程名( 杀死一个进程) $ kill -9 进程号 # 强制杀死一个进程 $ reboot Init 6 # 重启LINUX系统 $ Halt Init 0 Shutdown –h now # 关闭LINUX系统 打包/解压12345$ tar -c 创建包 –x 释放包 -v 显示命令过程 –z 代表压缩包 $ tar –cvf benet.tar /home/benet # 把/home/benet目录打包 $ tar –zcvf benet.tar.gz /mnt # 把目录打包并压缩 $ tar –zxvf benet.tar.gz # 压缩包的文件解压恢复 $ tar –jxvf benet.tar.bz2 # 解压缩 make编译12$ make # 编译 $ make install # 安装编译好的源码包 apt命令123456789101112131415161718$ apt-cache search package # 搜索包 $ apt-cache show package # 获取包的相关信息，如说明、大小、版本等 $ sudo apt-get install package # 安装包 $ sudo apt-get install package - - reinstall # 重新安装包 $ sudo apt-get -f install # 修复安装”-f = –fix-missing” $ sudo apt-get remove package # 删除包 $ sudo apt-get remove package - - purge # 删除包，包括删除配置文件等 $ sudo apt-get update # 更新源 $ sudo apt-get upgrade # 更新已安装的包 $ sudo apt-get dist-upgrade # 升级系统 $ sudo apt-get dselect-upgrade # 使用 dselect 升级 $ apt-cache depends package # 了解使用依赖 $ apt-cache rdepends package # 是查看该包被哪些包依赖 $ sudo apt-get build-dep package # 安装相关的编译环境 $ apt-get source package # 下载该包的源代码 $ sudo apt-get clean &amp;&amp; sudo apt-get autoclean # 清理无用的包 $ sudo apt-get check # 检查是否有损坏的依赖 $ sudo apt-get clean # 清理所有软件缓存（即缓存在/var/cache/apt/archives目录里的deb包）]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS常用命令]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-centos-command%2F</url>
    <content type="text"><![CDATA[关机 (系统的关机、重启以及登出 )的命令12345678$ shutdown -h now # 关闭系统(1) $ init 0 # 关闭系统(2) $ telinit 0 # 关闭系统(3) $ shutdown -h hours:minutes # 按预定时间关闭系统 $ shutdown -c # 取消按预定时间关闭系统 $ shutdown -r now # 重启(1) $ reboot # 重启(2) $ logout # 注销 文件和目录1234567891011121314151617181920212223242526$ cd /home # 进入 '/ home' 目录$ cd .. # 返回上一级目录 $ cd ../.. # 返回上两级目录 $ cd # 进入个人的主目录 $ cd ~user1 # 进入个人的主目录 $ cd - # 返回上次所在的目录 $ pwd # 显示工作路径 $ ls # 查看目录中的文件 $ ls -F # 查看目录中的文件 $ ls -l # 显示文件和目录的详细资料 $ ls -a # 显示隐藏文件 $ mkdir dir1 # 创建一个叫做 'dir1' 的目录$ mkdir dir1 dir2 # 同时创建两个目录 $ mkdir -p /tmp/dir1/dir2 # 创建一个目录树 $ rm -f file1 # 删除一个叫做 'file1' 的文件' $ rmdir dir1 # 删除一个叫做 'dir1' 的目录' $ rm -rf dir1 # 删除一个叫做 'dir1' 的目录并同时删除其内容 $ rm -rf dir1 dir2 # 同时删除两个目录及它们的内容 $ mv dir1 new_dir # 重命名/移动 一个目录 $ cp file1 file2 # 复制一个文件 $ cp dir/* . # 复制一个目录下的所有文件到当前工作目录 $ cp -a /tmp/dir1 . # 复制一个目录到当前工作目录 $ cp -a dir1 dir2 # 复制一个目录 $ ln -s file1 lnk1 # 创建一个指向文件或目录的软链接 $ ln file1 lnk1 # 创建一个指向文件或目录的物理链接 $ touch file1 # 创建一个文件 文件搜索命令123456789101112131415$ find / -name file1 # 从 '/' 开始进入根文件系统搜索文件和目录 $ find / -user user1 # 搜索属于用户 'user1' 的文件和目录 # 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件 $ find /home/user1 -name \*.bin $ find /usr/bin -type f -atime +100 # 搜索在过去100天内未被使用过的执行文件 $ find /usr/bin -type f -mtime -10 # 搜索在10天内被创建或者修改过的文件 $ locate \*.ps # 寻找以 '.ps' 结尾的文件 - 先运行 'updatedb' 命令 $ whereis file # 显示一个二进制文件、源码或man的位置 $ which file # 显示一个二进制文件或可执行文件的完整路径 # 在当前目录及其子目录所有.c和.h文件中查找 'expr'$ find -name '*.[ch]' | xargs grep -E 'expr' # 在当前目录及其子目录的常规文件中查找 'expr'$ find -type f -print0 | xargs -r0 grep -F 'expr' # 在当前目录中查找 'expr'$ find -maxdepth 1 -type f | xargs grep -F 'expr' 查看文件内容123456$ cat file1 # 从第一个字节开始正向查看文件的内容 $ tac file1 # 从最后一行开始反向查看一个文件的内容 $ more file1 # 查看一个长文件的内容 $ less file1 # 类似于 'more' 命令，但是它允许在文件中和正向操作一样的反向操作 $ head -2 file1 # 查看一个文件的前两行 $ tail -2 file1 # 查看一个文件的最后两行 打包和解压缩文件123456789101112131415161718192021$ bunzip2 file1.bz2 # 解压一个叫做 'file1.bz2'的文件 $ bzip2 file1 # 压缩一个叫做 'file1' 的文件 $ gunzip file1.gz # 解压一个叫做 'file1.gz'的文件 $ gzip file1 # 压缩一个叫做 'file1'的文件 $ gzip -9 file1 # 最大程度压缩 $ rar a file1.rar test_file # 创建一个叫做 'file1.rar' 的包 $ rar a file1.rar file1 file2 dir1 # 打包 'file1', 'file2' 以及目录 'dir1' $ rar x file1.rar # 解rar包 $ unrar x file1.rar # 解rar包 $ tar -cvf archive.tar file1 # 创建一个非压缩的tar包 $ tar -cvf archive.tar file1 file2 dir1 # 创建一个包含了 'file1', 'file2' 'dir1'的包 $ tar -tf archive.tar # 显示一个包中的内容 $ tar -xvf archive.tar # 释放一个包 $ tar -xvf archive.tar -C /tmp # 将压缩包释放到 /tmp目录下 （-c是指定目录）$ tar -cvfj archive.tar.bz2 dir1 # 创建一个bzip2格式的压缩包 $ tar -xvfj archive.tar.bz2 # 解压一个bzip2格式的压缩包 $ tar -cvfz archive.tar.gz dir1 # 创建一个gzip格式的压缩包 $ tar -xvfz archive.tar.gz # 解压一个gzip格式的压缩包 $ zip file1.zip file1 # 创建一个zip格式的压缩包 $ zip -r file1.zip file1 file2 dir1 # 将几个文件和目录同时压缩成一个zip格式的压缩包 $ unzip file1.zip # 解压一个zip格式压缩包 磁盘空间操作的命令1234$ df -h # 显示已经挂载的分区列表 $ ls -lSr |more # 以尺寸大小排列文件和目录 $ du -sh dir1 # 估算目录 'dir1' 已经使用的磁盘空间$ du -sk * | sort -rn # 以容量大小为依据依次显示文件和目录的大小 RPM1234567891011121314151617181920212223242526272829$ rpm -ivh package.rpm # 安装一个rpm包 $ rpm -ivh --nodeeps package.rpm # 安装一个rpm包而忽略依赖关系警告 $ rpm -U package.rpm # 更新一个rpm包但不改变其配置文件 $ rpm -F package.rpm # 更新一个确定已经安装的rpm包 $ rpm -e package_name.rpm # 删除一个rpm包 $ rpm -qa # 显示系统中所有已经安装的rpm包 $ rpm -qa | grep httpd # 显示所有名称中包含 "httpd" 字样的rpm包 $ rpm -qi package_name # 获取一个已安装包的特殊信息 $ rpm -ql package_name # 显示一个已经安装的rpm包提供的文件列表 $ rpm -qc package_name # 显示一个已经安装的rpm包提供的配置文件列表 $ rpm -q package_name --whatrequires # 显示与一个rpm包存在依赖关系的列表 $ rpm -q package_name --whatprovides # 显示一个rpm包所占的体积 $ rpm -q package_name --scripts # 显示在安装/删除期间所执行的脚本l $ rpm -q package_name --changelog # 显示一个rpm包的修改历史 $ rpm -qf /etc/httpd/conf/httpd.conf # 确认所给的文件由哪个rpm包所提供 $ rpm -qp package.rpm -l # 显示由一个尚未安装的rpm包提供的文件列表 $ rpm --import /media/cdrom/RPM-GPG-KEY # 导入公钥数字证书 $ rpm --checksig package.rpm # 确认一个rpm包的完整性 $ rpm -qa gpg-pubkey # 确认已安装的所有rpm包的完整性 # 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 $ rpm -V package_name $ rpm -Va # 检查系统中所有已安装的rpm包- 小心使用 $ rpm -Vp package.rpm # 确认一个rpm包还未安装 # 从一个rpm包运行可执行文件 $ rpm2cpio package.rpm | cpio --extract --make-directories *bin* # 从一个rpm源码安装一个构建好的包 $ rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm # 从一个rpm源码构建一个 rpm 包 $ rpmbuild --rebuild package_name.src.rpm YUM1234567891011$ yum install package_name # 下载并安装一个rpm包 # 将安装一个rpm包使用你自己的软件仓库为你解决所有依赖关系 $ yum localinstall package_name.rpm $ yum update package_name.rpm # 更新当前系统中所有安装的rpm包 $ yum update package_name # 更新一个rpm包 $ yum remove package_name # 删除一个rpm包 $ yum list # 列出当前系统中安装的所有包 $ yum search package_name # 在rpm仓库中搜寻软件包 $ yum clean packages # 清理rpm缓存删除下载的包 $ yum clean headers # 删除所有头文件 $ yum clean all # 删除所有缓存的包和头文件 ​ 查看系统信息12345678910111213141516171819$ arch # 显示机器的处理器架构(1) $ uname -m # 显示机器的处理器架构(2) $ uname -r # 显示正在使用的内核版本 $ dmidecode -q # 显示硬件系统部件 - (SMBIOS / DMI) $ hdparm -i /dev/hda # 罗列一个磁盘的架构特性 $ hdparm -tT /dev/sda # 在磁盘上执行测试性读取操作 $ cat /proc/cpuinfo # 显示CPU info的信息 $ cat /proc/interrupts # 显示中断 $ cat /proc/meminfo # 校验内存使用 $ cat /proc/swaps # 显示哪些swap被使用 $ cat /proc/version # 显示内核的版本 $ cat /proc/net/dev # 显示网络适配器及统计 $ cat /proc/mounts # 显示已加载的文件系统 $ lspci -tv # 罗列 PCI 设备 $ lsusb -tv # 显示 USB 设备 $ date # 显示系统日期 $ cal 2007 # 显示2007年的日历表 $ date 041217002007.00 # 设置日期和时间 - 月日时分年.秒 $ clock -w # 将时间修改保存到 BIOS 挂载命令1234567891011121314151617# 挂载一个叫做hda2的盘 （注：确定目录 '/ mnt/hda2' 已经存在） $ mount /dev/hda2 /mnt/hda2 # 卸载一个叫做hda2的盘（先从挂载点 '/ mnt/hda2' 退出）$ umount /dev/hda2 # 当设备繁忙时强制卸载 $ fuser -km /mnt/hda2# 运行卸载操作而不写入 /etc/mtab 文件（当文件为只读或当磁盘写满时非常有用） $ umount -n /mnt/hda2 # $ mount /dev/fd0 /mnt/floppy # 挂载一个软盘 $ mount /dev/cdrom /mnt/cdrom # 挂载一个光盘$ mount /dev/hdc /mnt/cdrecorder # 挂载一个cdrw或dvdrom $ mount /dev/hdb /mnt/cdrecorder # 挂载一个cdrw或dvdrom $ mount -o loop file.iso /mnt/cdrom # 挂载一个文件或ISO镜像文件 $ mount -t vfat /dev/hda5 /mnt/hda5 # 挂载一个Windows FAT32文件系统 $ mount /dev/sda1 /mnt/usbdisk # 挂载一个usb 捷盘或闪存设备# 挂载一个windows网络共享 $ mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 用户和群组1234567891011121314151617181920212223242526272829303132$ groupadd group_name # 创建一个新用户组 $ groupdel group_name # 删除一个用户组 $ groupmod -n new_group_name old_group_name # 重命名一个用户组 # 创建一个属于 "admin" 用户组的用户 $ useradd -c "Name Surname " -g admin -d /home/user1 -s /bin/bash user1 $ useradd user1 # 创建一个新用户 $ userdel -r user1 # 删除一个用户 ( '-r' 同时删除除主目录) $ passwd user1 # 修改一个用户的口令 (只允许root执行) $ chage -E 2005-12-31 user1 # 设置用户口令的失效期限 $ ls -lh # 显示权限 # 设置目录的所有人(u)、群组(g)以及其他人(o)以读(r)、写(w)和执行(x)的权限 $ chmod 777 directory1# 删除群组(g)与其他人(o)对目录的读写执行权限 $ chmod 700 directory1 # 改变一个文件的所有人属性，为use1$ chown user1 file1 # 改变一个目录的所有人属性并同时改变改目录下所有文件的属性都为use1所有 $ chown -R user1 directory1 # 改变文件的群组为group1 $ chgrp group1 file1# 改变一个文件的所有人和群组属性，所属组为group1，用户为use1。 $ chown user1:group1 file1 # 罗列一个系统中所有使用了SUID控制的文件 $ find / -perm -u+s # 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 $ chmod u+s /bin/file1 # 禁用一个二进制文件的 SUID位 $ chmod u-s /bin/file1 $ chmod g+s /home/public # 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 $ chmod g-s /home/public # 禁用一个目录的 SGID 位 $ chmod o+t /home/public # 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 $ chmod o-t /home/public # 禁用一个目录的 STIKY 位]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS端口]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-centos-port%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334# 查看80端口占用$ lsof -i tcp:80# 列出所有端口$ netstat -ntlp# 开启端口（以80端口为例）# 方法一：$ /sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT # 写入修改$ /etc/init.d/iptables save # 保存修改$ service iptables restart # 重启防火墙，修改生效# 方法二：$ vi /etc/sysconfig/iptables # 打开配置文件加入如下语句:-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT # 重启防火墙，修改完成# 关闭端口# 方法一：$ /sbin/iptables -I INPUT -p tcp --dport 80 -j DROP # 写入修改$ /etc/init.d/iptables save # 保存修改$ service iptables restart # 重启防火墙，修改生效# 方法二：$ vi /etc/sysconfig/iptables #打开配置文件加入如下语句:-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j DROP # 重启防火墙，修改完成# 查看端口状态$ /etc/init.d/iptables status# 查询防火墙状态:$ service iptables status# 停止防火墙:$ service iptables stop # 启动防火墙:$ service iptables start # 重启防火墙:$ service iptables restart # 永久关闭防火墙:$ chkconfig iptables off # 永久关闭后启用:$ chkconfig iptables on]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS无法上网问题]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-centos-network%2F</url>
    <content type="text"><![CDATA[1234$ cd /etc/sysconfig/network-scripts/# ls 查看一下ifcfg-eno后面对应的数字是什么，以eno32为例$ vim ifcfg-eno32 # 设置ONBOOT=yes 即开启自动启用网络连接$ service network restart 重启网络]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS git升级]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-centos-git-update%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617# 安装编译git时需要的包$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel$ yum install gcc perl-ExtUtils-MakeMaker# 删除已有的git$ yum remove git# 下载git源码$ cd /usr/src$ wget https://www.kernel.org/pub/software/scm/git/git-2.0.5.tar.gz$ tar xzf git-2.0.5.tar.gz# 编译安装$ cd git-2.0.5$ make prefix=/usr/local/git all$ make prefix=/usr/local/git install$ echo "export PATH=$PATH:/usr/local/git/bin" &gt;&gt; /etc/bashrc$ source /etc/bashrc# 检查一下版本号$ git --version]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS yum,npm源更换]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-centos-yum-npm%2F</url>
    <content type="text"><![CDATA[12345678# yum源更换# 备份$ mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup$ cd /etc/yum.repos.d/ ​$ wget http://mirrors.163.com/.help/CentOS7-Base-163.repo# 生成缓存：$ yum clean all$ yum makecache ​ 1234567# npm源更换$ alias cnpm="npm --registry=https://registry.npm.taobao.org \--cache=$HOME/.npm/.cache/cnpm \--disturl=https://npm.taobao.org/dist \--userconfig=$HOME/.cnpmrc" ​# npm升级$ npm update npm ​]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADB常用命令]]></title>
    <url>%2F2018%2F04%2F01%2Fandriod-adb%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021$ adb devices # 查看设备$ adb install -r &lt;package&gt; #安装apk$ adb uninstall &lt;package&gt; #卸载apk$ adb -s 设备号 install xxx.apk # 从模拟器或手机中复制一个文件或文件夹（递归的）使用：$ adb pull &lt;remote&gt; &lt;local&gt;# 复制一个文件或文件夹（递归的）到模拟器或手机中使用：$ adb push &lt;local&gt; &lt;remote&gt;# 在这个命令中和引用的是文件或文件夹的路径，在开发用电脑上的是local，在模拟器或手机上的是remote$ adb start-server #启动adb server$ adb kill-server #停止adb server# 列出系统应用的所有包名：$ adb shell pm list packages -s# 列出除了系统应用的第三方应用包名：$ adb shell pm list packages -3# 使用 grep 来过滤：$ adb shell pm list packages | grep qq# 清除应用数据与缓存$ adb shell pm clear &lt;packagename&gt;# 启动应用$ adb shell am start -n 包名/类名]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>ADB</tag>
        <tag>Andriod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Airmon-ng简要操作]]></title>
    <url>%2F2018%2F04%2F01%2Fcs-kali-airmon-ng%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718$ airmon-ng check kill # 杀进程$ airmon-ng start wlan0 # 启动无效网卡$ airodump-ng wlan0mon # 探测# 抓包$ airodump-ng --bssid XX:XX:XX:XX:XX:XX -c 1 -w testap wlan0mon --bssid 是路由器的mac地址 -w 是写入到文件longas中 -c 11 是频道11# 攻击$ aireplay-ng -0 0 -a XX:XX:XX:XX:XX:XX -c XX:XX:XX:XX:XX:XX wlan0mon -0 采用deauth攻击模式，后面跟上攻击次数 -a 后跟路由器的mac地址 -c 后跟客户端的mac地址# 直接破解$ aircrack-ng -w Wordlists.txt CAP-01.cap# 转换后用hashcat跑$ cap2hccapx.exe testap.cap test.hccapx$ hashcat64.exe -m 2500 -D 2 test.hccapx pass.txt]]></content>
      <categories>
        <category>安全π</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>Kali</tag>
        <tag>Airmon-ng</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu静态IP和SSH配置]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-ubuntu-ip-xshell%2F</url>
    <content type="text"><![CDATA[1234567891011121314# 修改静态ip$ vim /etc/network/interfaces auto eth0 iface eth0 inet static address 192.168.1.100 netmask 255.255.255.0 gateway 192.168.1.1# DNS解析$ vim /etc/resolv.conf nameserver 192.168.1.1$ vim /etc/resolvconf/resolv.conf.d/base nameserver 192.168.1.1# 要将/etc/NetworkManager/目录下的system-connections删除，或者移动到其他目录下$ sudo/etc/init.d/networking restart # 重启网卡 12345678# 安装ssh$ sudo apt-get install openssh-server # 安装$ ps -e |grep ssh # 查看$ /etc/init.d/ssh start # 启动# 如果无法启动$ vim /etc/ssh/sshd_config # 将 PermitRootLogin改为yes：$ sudo /etc/init.d/ssh restart]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu安装Ftp和Smaba]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-ubuntu-ftp-smaba%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021# 安装 ftp$ apt-get install vsftpd# 添加用户和权限# 新建"/home/uftp"目录作为用户主目录# 新建用户uftp并设置密码$ sudo useradd -d /home/uftp -s /bin/bash uftp$ passwd uftp XXX$ vim /etc/vsftpd.conf # 配置文件 userlist_deny=NO userlist_enable=YES userlist_file=/etc/allowed_users seccomp_sandbox=NO chroot_list_enable=YES chroot_list_file=/etc/chroot_list# 添加用户uftp到allowed_users,chroot_list$ vim /etc/allowed_users$ vim /etc/chroot_list# 启动/关闭/重启服务$ sudo /etc/init.d/vsftpd start$ sudo /etc/init.d/vsftpd stop$ sudo /etc/init.d/vsftpd restart 123456789101112131415161718192021222324252627# 安装 samba$ sudo apt-get install samba# smbclient: $ sudo apt-get install smbclient# 修改配置文件$ vim /etc/samba/smb.conf# 在文件末尾加上如下[share]（相当于在home目录项增加了一个新用户） [share] comment = Share Folder require password browseable = yes path = /home/share create mask = 0777 directory mask = 0777 valid users = share force user = nobody force group = nogroup public = yes writable = yes available = yes# 保存退出后重启samba：$ sudo /etc/init.d/samba restart# 切换到 /home/目录下创建一个用户目录：$ sudo mkdir share# 设置目录的权限：（777代表最高权限，可读可写可执行）$ chmod 777 share# 添加用户到samba$ smbpasswd -a starbucks]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>Ftp</tag>
        <tag>Smaba</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql简单安装配置]]></title>
    <url>%2F2018%2F04%2F01%2Fdb-mysql-init%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617my.ini[mysql]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]#设置3306端口port = 3306 # 设置mysql的安装目录basedir=D:\mysql\mysql-5.6.17-winx64# 设置mysql数据库的数据的存放目录datadir=D:\mysql\mysql-5.6.17-winx64\data# 允许最大连接数max_connections=200# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB win-mysql安装服务123$ cd D:\mysql\mysql-5.6.17-winx64\bin$ mysqld install # 安装服务$ mysqld remove # 卸载服务 初始化123$ net start mysql # 启动服务# 先删除 mysql 下的data文件夹$ mysqld --initialize # 初始化 设置密码12345$ net stop MySQL # 关闭服务$ mysqld --skip-grant-tables # 用安全模式打开$ mysql -u root -p # 登录，密码为空，直接回车$ use mysql$ set password for root@localhost = password('123'); 登入12$ mysql -u root -p # 回车输入密码$ mysqladmin -u root -p password 密码 # 设置密码 远程登入1234567$ use mysql# 插入$ GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION; # 刷新$ flush privileges;# 查看是否成功$ select host,user from user; linux-mysql安装123$ wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm$ rpm -ivh mysql-community-release-el7-5.noarch.rpm$ yum install mysql-community-server 启动/关闭服务1$ service mysqld restart/stop 设置密码123$ mysql -u root # 首次无密$ use mysql$ set password for root@localhost = password('123'); 远程登录1234# 把在所有数据库的所有表的所有权限赋值给位于所有IP地址的root用户$ grant all privileges on *.* to root@'%'identified by 'password'# 如果是新用户而不是root，则要先新建用户$ create user 'username'@'%' identified by 'password']]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA Top10热键]]></title>
    <url>%2F2018%2F04%2F01%2Fjava-idea-hot-key%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819# Top 10 切来切去：Ctrl+Tab# Top 9 选你所想：Ctrl+W# Top 8 代码生成：Template/Postfix +Tab# Top 7 发号施令：Ctrl+Shift+A# Top 6 无处藏身：Shift+Shift# Top 5 自动完成：Ctrl+Shift+Enter# Top 4 创造万物：Alt+Insert# Top 3 自我修复：Alt+Enter# Top 2 重构一切：Ctrl+Shift+Alt+T# Top 1 智能补全：Ctrl+Shift+Space]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB]]></title>
    <url>%2F2018%2F04%2F01%2Fdb-mongodb-basis%2F</url>
    <content type="text"><![CDATA[123456$ cd d:/soft/mongodb/bin# 设置log和data路径，需要创建data文件夹$ mongod.exe --logpath E:\DB\MONGO_DB\mongodb.log --logappend --dbpath E:\DB\MONGO_DB\data --directoryperdb --serviceName MongoDB -install $ net start MongoDB # 启动服务$ net stop MongoDB # 停止服务 mongo基础使用123456$ db.getCollection('email_zero').find(&#123;&#125;) # 查询表$ db.email_zero.stats() # 表信息$ db.email_zero.ensureIndex(&#123;"email":1&#125;) # 建立索引$ db.email_zero.find(&#123;"email":"123@163.com"&#125;).pretty() # 查询例子# 导出数据$ mongoexport -d admin -c mydb --csv -f tid,uid,username,isupdate,phone -o mydb.dat 去重脚本12345678var rs = db.email_zero.aggregate([&#123;$group:&#123;_id:"email",count:&#123;$sum:1&#125;&#125;&#125;,&#123;$match:&#123;count:&#123;$gt:1&#125;&#125;&#125;])for(var i in rs.result)&#123; var r = rs.result[1].count; var k = rs.result[1]._id; for(var ii=0;ii&lt;r-1;ii++)&#123; db.biu.remove(&#123;"email":k&#125;,true) &#125; &#125;]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2018%2F04%2F01%2Fhexo-learning%2F</url>
    <content type="text"><![CDATA[12345$ npm install -g hexo-cli​ #hexo$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install$ git clone https://github.com/iissnan/hexo-theme-next themes/next 常用插件1234567891011# 安装 less# 主题默认使用 less 作为 css 预处理工具。$ npm install hexo-renderer-less --save# 安装 feed# 用于生成 rss。$ npm install hexo-generator-feed --save# 安装 json-content# 用于生成静态站点数据，用作站内搜索的数据源。$ npm install hexo-generator-json-content --save$ npm install hexo-deployer-git --save` hexo命令1234567891011121314$ hexo new post title$ hexo -d 提交只git$ hexo -w 监视文章文件变动$ hexo -s 启动服务$ hexo -g 生成页面$ hexo list &lt;type&gt;$ hexo --safe 安全模式$ hexo --debug 调试模式$ hexl --slient 简洁模式# 重新安装hexo-util $ npm install -- save-dev hexo-util# 如果出现# Block-scoped declarations (let, const, function, class) not yet supported outside strict mode$ 'use strict' 其他插件12345678910# hexo-addlink：在文章最末添加永久链接及版权声明，建议安装# hexo-generator-search: 本地搜索# hexo-index-anything: 更改首页为任意的页面# hexo-encrypt：加密你的博客# hexo-ruby-character 文字拼音# hexo Tag Cloud 标签云# hexo-uuid# sitemap 站点地图$ npm install hexo-generator-searchdb --save$ npm uninstall ​]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F04%2F01%2Fgit%2F</url>
    <content type="text"><![CDATA[12$ git config --global user.name "name"$ git config --global user.email "***@**.com" 12$ ssh-keygen -t rsa -C "email"$ ssh -T git@git.oschina.net $ ssh -T git@github.com 查看信息1$ git config --list 文本编辑器1$ git config --global core.editor emacs 代码比较1$ git config --global merge.tool vimdiff 创建版本库123456789101112131415161718192021222324252627282930# 选择一个合适的地方，创建一个空目录：$ mkdir xxoo$ cd xxoo$ pwd# 把这个目录变成Git可以管理的仓库：$ git init# 1.把文件添加到仓库$ git add readme.txt# 2.把文件提交到仓库$ git commit -m "wrote a readme file"# 检查文件状态$ git status# 忽略某些文件$ cat .gitignore *.[oa] *~# 查看尚未暂存的文件更新了哪些部分$ git diff# 要看已经暂存起来的文件和上次提交时的快照之间的差异$ git diff - staged# 提交更新$ git commit -m "xxx"# 跳过使用暂存区域$ git commit -a -m "xxx"# 移除文件 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强删除选项 -f$ git rm xxx# 仅是从跟踪清单中删除$ git rm --cached XXX# 日志$ git log --pretty=oneline 版本123456789101112# 版本回退 git 用head表示当前版本 head^上一个版本$ git reset --hard HEAD^# 回到任意版本$ git reset --hard commitId# 用来记录你的每一次命令：$ git reflog# 撤销修改(文件在工作区的修改全部撤销)# 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；# 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。$ git checkout -- file# 暂存区的修改撤销掉（unstage），重新放回工作区$ git reset HEAD file 远程仓库github1234567$ git remote add origin git@oschina.net:***/***.git# 本地库push到github （第一次用-u，后面就不用）$ git push -u origin master # 克隆别人项目(mycode 自定义目录名称)$ git clone git://url mycode# 查看远程仓库(详情)$ git remote -v 分支管理12345678910111213141516171819202122232425262728# 参数表示创建并切换$ git checkout -b dev# 查看当前分支 *$ git branch# 切换分支$ git checkout master# 合并分支$ git merge dev# 删除分支$ git branch -d dev# 强行删除未合并分支$ git branch -D name# 分支合并图$ git log --graph --pretty=oneline --abbrev-commit# 禁用fast forward$ git merge --no--ff -m "xxoo" dev# 1.可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：# 2.创建bug分支，临时分支# 3.切回分支 查看工作区# 4.回复工作区$ git stash$ git checkout -b issue-101$ git stash list$ git stash apply $ git stash drop# 或者$ git stash pop# 多次stash，再恢复指定stash$ git stash apply stash&#123;*&#125; 推送分支到远程(多人管理)12345$ git push origin master# git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送$ git pull# git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：$ git branch --set-upstream dev origin/dev 标签123456789101112131415# 打标签+id$ git tag v1.0 123456# 查看标签详情$ git show v1.0# 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：$ git tag -a v1.0 -m 'xxoo' 123456# 删除$ git tag -d v1.0# 推到远程,一次性推送全部尚未推送到远程的本地标签：$ git push origin v1.0$ git push origin --tags# 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：$ git tag -d v1.0# 然后，从远程删除。删除命令也是push，但是格式如下：$ git push origin :refs/tags/v1.0 推送失败12345$ cd to .git/config$ vim vonfig # url = $ git pull --rebase origin master# 执行上面代码后可以看到本地代码库中多了README.md文件]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑盒测试清单]]></title>
    <url>%2F2018%2F04%2F01%2Ftest-black-box-testing%2F</url>
    <content type="text"><![CDATA[收集信息 手动访问站点 使用爬虫来抓取（手工）无法访问或隐藏的内容 检查泄露信息的文件，如robots.txt, sitemap.xml, .DS_Store 检查主要的搜索引擎索引的此站点的公开内容 检查不同的浏览器UA获取的内容的差异（如使用爬虫的UA访问手机站点） 检查WEB应用程序的指纹（Fingerprinting） 确认使用的技术 确认用户角色 确认应用程序的入口地址 确认客户端代码 确认不同的版本的差异（如web, mobile web, mobile app, web services） 确认位于同一主机或业务相关的应用程序 确认所有的主机名和端口 确认第三方的托管内容 配置管理 检查常用的应用程序和管理URL 检查旧文件、备份文件和未引用文件是否存在 检查支持的HTTP方法和XST漏洞 检查对文件后缀的处理 检查安全HTTP头（如CSP, X-Frame-Options, HSTS） 测试安全策略（如Flash, Silverlight, robots） 在线上环境测试非生产数据或做相反的操作 检查客户端代码中的敏感信息（如API keys,凭据等） 安全传输 检查SSL版本、算法和密钥长度 检查数字证书有效性 检查凭据是否只通过HTTPS传输数据 检查登陆表单是否只通过HTTPS传输数据 检查会话令牌是否只通过HTTPS传输 检查是否使用了HSTS 认证 测试枚举用户 测试认证绕过 测试暴力破解保护 测试密码规则的质量 测试记住密码功能 测试密码表单的自动完成的功能 测试密码重置和找回 测试密码修改流程 测试验证码 测试多因子认证 测试注销功能 测试HTTP的缓存管理（如Pragma, Expires, Max-age） 测试默认登陆账号 测试用户认证历史 测试账号锁定和密码修改成功的通知渠道 测试跨应用程序共享模式/SSO的一致性 会话管理 确定应用程序管理会话的方式（如将cookie tokens、url中的token） 检查会话cookie的标示(httpOnly和secure) 检查会话cookie的返回（path和domain） 检查会话cookie的有效期（expires和 max-age） 检查会话cookie的过期失效 检查会话cookie的相对超时失效 检查会话cookie退出后失效 测试用户是否可以同时拥有多个会话 测试会话cookie的随机性 确认会话令牌在登陆、角色变化和退出时的更新 测试跨应用共享session会话的一致性 测试会话过载（未限制会话应用范围） 测试是否存在CSRF和点击劫持漏洞 授权 测试路径遍历 测试绕过授权 测试垂直访问控制问题 测试水平访问控制问题 测试授权检查缺失 数据验证 测试反射型XSS 测试存储型XSS 测试DOM型XSS 测试CSF（flash XSS） 测试HTML注入 测试SQL注入 测试LDAP注入 测试ORM注入 测试XML注入 测试XXE注入 测试SSI注入 测试XPath注入 测试XQuery注入 测试IMAP/SMTP注入 测试Code注入 测试EL注入 测试Command注入 测试Overflow （堆, 栈和整形溢出） 测试Format String（错误的字符串格式化） 测试incubated vulnerabilities（缺陷孵化） 测试HTTP Splitting/Smuggling（协议层） 测试HTTP Verb Tampering（权限干涉） 测试Open Redirection 测试本地文件包含 测试远程文件包含 比较客户端与服务端的验证规则 测试NoSQL注入 测试HTTP参数污染 测试自动绑定 测试Mass Assignment（ror经典漏洞） 测试NULL/Invalid Session Cookie 拒绝服务 测试反自动化/机器请求 测试账号锁定 测试HTTP 协议DoS 测试SQL通配符DoS/sleep Dos 业务逻辑 测试功能滥用 测试缺乏不可否认性（非对称加密作用） 测试信任关系 测试数据完整性 测试指责分离 密码学 检查应加密数据是否加密 根据上下文检查是否使用了错误的算法 检查使用弱算法 检查是否合理使用盐 检查随机函数（的随机性） 风险功能—文件上传 检查可接受的文件类型是否在白名单内 检查文件尺寸限制、上传频率和总文件数的阈值与限制情况 检查文件内容是否与定义的文件类型相符 检查所有上传的文件都经过杀毒软件扫描 检查不安全的文件名是否经过处理 检查不能在web根目录下直接访问上传文件 检查上传的文件是否存储在相同的主机名和端口 检查文件和其他媒体继承了身份验证和授权功能 风险功能—支付信息 测试WEB服务器或应用程序是否存在已知漏洞和配置问题 测试默认或易被猜到的密码 测试生产环境的非生产数据或做相反的* 测试 测试注入漏洞 测试缓冲区溢出 测试不安全的加密存储 测试传输层保护不足 测试不适当的错误处理 测试CVSS v2 评分&gt; 4.0的全部漏洞 测试身份验证和授权的问题 测试CSRF HTML 5 测试WEB消息传递 测试WEB本地存储SQL注入 检查CORS的实现 检查离线的WEB应用程序]]></content>
      <categories>
        <category>测试π</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>黑盒测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLMap]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-kali-sqlmap%2F</url>
    <content type="text"><![CDATA[12345678910111213# 判读是否有注入点 ​$ python sqlmap.py -u 'RUL'# 获取数据库$ python sqlmap.py -u 'RUL' --dbs# 当前使用数据库$ python sqlmap.py -u 'RUL' --current-db# 获取指定库的所有表$ python sqlmap.py -u 'RUL' --table -D "数据库名"#获取表中的字段$ python sqlmap.py -u 'RUL' --columns -T "表名" -D "数据库名"#读取指定字段内容$ python sqlmap.py -u 'RUL' --dump -C "字段，字段，字段" -T "表名" -D "数据库名"#(dump为转存数据） 常用参数12345678910111213141516171819202122232425262728293031323334353637# 测试注入点权限$ python sqlmap.py -u 'RUL' --privileges #所有用户权限$ python sqlmap.py -u 'RUL' --privileges -U sa #sa用户权限# 执行shell命令$ python sqlmap.py -u 'RUL' --os-cmd="net user" #执行net user命令$ python sqlmap.py -u 'RUL' --os-shell #系统交互的shell#执行sql命令$ python sqlmap.py -u 'RUL' --sql-shell #sql交互shell$ python sqlmap.py -u 'RUL' --sql-query="sql语句"# post提交方式$ python sqlmap.py -u 'RUL' --data "post参数"# 显示详细等级 # 0：只显示Python的回溯，错误和关键消息。 # 1：显示信息和警告消息。 # 2：显示调试消息。 # 3：有效载荷注入。 # 4：显示HTTP请求。 # 5：显示HTTP响应头。 # 6：显示HTTP响应页面的内容 $ python sqlmap.py -u 'RUL' -v 1 #注入http请求$ python sqlmap.py -r head.txt --dbs [head.txt POST /login.php HTTP/1.1 Host:www.secbug.org User-Agent:Mozilla/5.0 username=admin&amp;password=admin888]# 直接连接数据库$ python sqlmap.py -d "mysql://admin:admin@127.0.0.1:3306/test" --dbs# 注入等级$ python sqlmap.py -u 'RUL' --leavl 3# 语句插入到指定位置$ python sqlmap.py -u 'http://www.xxser.com/id/2*.html' --dbs# 使用插件$ python sqlmap.py -u 'RUL' -tamper "插件名"# 获取帮助$ python sqlmap.py -h 🌰🌰🌰1234567891011121314151617181920212223242526272829# 🌰：$ SELCECT *$ FORM products$ WHERE category = 'bike' AND '1'='2'$ UNION SELECT *$ FROM new_products;# 🌰：$ SELECT *$ FROM products$ WHERE idproduct = 1+1 (?id=%2B1)(+的url编码%2B)# 数据库注释# SQLserver Oracle Postgresql --(双联字符) /* */# Mysql -- # /* */# 数据库服务器版本# SQLserver $ select @@version# Mysql$ select version()$ select @@version# Oracle$ select banner from v$version$ select banner from v$version where rownum=1# Postgresql$ select version()]]></content>
      <categories>
        <category>安全π</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>Kali</tag>
        <tag>Sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali源更换]]></title>
    <url>%2F2018%2F04%2F01%2Fcs-kali-sources-list-and-ssr%2F</url>
    <content type="text"><![CDATA[12345678$ vim /etc/apt/sources.list​#中科大deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib​$ apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get dist-upgrade ​$ apt-get clean ​# apt-get dist-upgrade 更新系统以及所有依赖包$ apt-get installopen-vm-tools-desktop fuse #安装开源vm tools kali-ss12345678$ apt-get install qt5-qmake qtbase5-dev libbotan1.10-dev pkg-config debhelper libqrencode-dev libzbar-dev libappindicator-dev cmake # 安装编译环境$ git clone https://github.com/shadowsocks/libQtShadowsocks.git #克隆项目$ dpkg-buildpackage -uc -us -b$ dpkg -i ../libqtshadowsocks_1.10.0-1_amd64.deb ../libqtshadowsocks-dev_1.10.0-1_amd64.deb# 若出错，则更改版本信息$ git clone https://github.com/shadowsocks/shadowsocks-qt5.git$ dpkg-buildpackage -uc -us -b$ dpkg -i ../shadowsocks-qt5_2.8.0-1_amd64.deb win-ss1$ wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh tor-network-bridgeobfs2网桥 、obfs3网桥、obfs4网桥（推荐） 、scramblesuit网桥]]></content>
      <categories>
        <category>安全π</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>Kali</tag>
        <tag>Linux</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理与方法论]]></title>
    <url>%2F2018%2F04%2F01%2Ftime-management%2F</url>
    <content type="text"><![CDATA[时间管理有很多种方法，而GTD（全称：Getting Things Done）就是其中一套行之有效的方法，也是现在最受欢迎的方法。Getting Things Done 翻译成中文就是“把事情做完”，GTD的核心理念概括就是 “通过记录的方式把头脑中的各种事情移出来，然后整理安排自己去执行”。带着一些自己的理解，下面谈一谈我对GTD的理解以及方法论，GTD的核心步骤为五步：收集、处理、管理、执行、回顾。 收集 —— 收集记录人的大脑能储存很多东西，但有限，不要相信某事情发生后过了一段时间你还能记得，释放大脑的储存负载，让大脑着重于去思考，平时有什么信息、任务和灵感要在忘记之前用工具记录下来，使用的工具要尽可能的方便，易用，便捷。 处理 —— 处理分类只有及时处理信息，对信息及时做出决定和归纳成类，你才能避免信息的堆积和碎片化，处理信息时采用二分钟法则和四象限法则，二分钟方法就是如果一件事情两分钟内能解决的事情，无论是何种事情，马上着手解决掉，如果不能再进行分类。分类则采用四象限法则，四象限法则是把工作按照重要和紧急两个不同的程度划分成四个“象限”：既紧急又重要、重要但不紧急、紧急但不重要、既不紧急也不重要。 计划 —— 计划安排除了既有的日程安排外，可以设定每日，每周，每月，每年你需要完成的重大事件，把他们排进日程表。每天要做的事件采用三只青蛙理论，前天晚上睡觉前设定第二天最重要的三件事，起床后就可以开始着手这三件事了（同理可用于每月的“三只青蛙”, 每季度的“三只青蛙”，每年的“三只青蛙”）。每周要做的事采用习惯21天效应，一件事只要坚持21天就能习惯成自然，成为一种习惯。每月要做的事采用日历行程表的方法，将每月要做的事排进日程表。每年要做的事采用原望清单法，让自己每年都有收获和进步. 执行 —— 坚决执行执行是Getting Things Done最关键的一步，也是成功与否的关键，要言行一致，制定了计划就一定得做到，这能很好地提升你的自我认同感。执行时你应当在不分心的情境下，一次只执行一件事，既不要多线工作，也不要让你的工作突然中断。采用番茄工作法，将番茄时间设为25分钟，专注工作，中途不做任何与该任务无关的事，直到番茄时钟响起，然后短暂休息5分钟继续番茄时钟，每4个番茄时段可多休息一会儿。番茄工作法极大地提高了工作的效率，还会有意想不到的成就感。 回顾 —— 回顾检查目前我采用的是一周回顾一次，采用PDCA循环法对长期目标、中期目标和短期目标进行回顾，对工作和其它事情进行回顾，看看哪里做的不好，需要改进，重新做出调整计划。这样能使得计划更有效地进行，更加合乎工作程序的逻辑。]]></content>
      <categories>
        <category>时间π</category>
      </categories>
      <tags>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Search]]></title>
    <url>%2F2018%2F03%2F31%2Fg00gle-search%2F</url>
    <content type="text"><![CDATA[搜索知乎上的相关话题：1intext:"星巴克" site:zhihu.com/question/ 搜索百度网盘上的资料1intitle:"星巴克" site:pan.baidu.com 日常生活类1weather/time/sunrise/sundown+Seattle 查询作者的全部作品1books by Starbucks 查询几个信息（ + 、or 号的运用）12“星巴克 + Starbucks”“星巴克 or Starbucks” 找图片1234可以使用inurl语法迅速找到想要的图片搜索：“星巴克” inurl:photo可以用intitle语法找到这类网页。搜索：“intitle:“星巴克” picture” 找软件123451）直接以软件名称以及版本号为关键字查询。2）可以增加“下载”或者“download”为关键字。3）用“” 精确搜索，如：搜索：“winzip 8.0 下载”4）可以用inurl语法直接搜索这些下载目录搜索：PS inurl:download （搜索PS 软件下载） “” 双引号表示完全匹配，搜索：“星巴克” A -B搜索包含A但不包含B的结果（请注意A后面的空格不能省略） 模糊搜索：很多时候想搜一个东西但是不确定具体名字，可以用星号代替忘了的字，像搜 [星*克]； site 搜索结果局限于某个具体网站1site:starbucks.com.cn 注意：site后的冒号为英文字符，而且，冒号后不能有空格，否则，“site:”将被作为一个搜索的关键字。此外，网站域名不能有“http”以及“www”前缀，也不能有任何“/”的目录后缀； link 返回所有链接到某个URL地址的网页。12示例：搜索所有含指向星巴克“www.starbucks.com.cn”链接的网页。搜索：“link:www.starbucks.com.cn” inurl 用于搜索查询词出现在url 中的页面12345搜索：inurl:搜索引擎优化返回的结果都是网址url中包含“搜索引擎优化”的页面。由于关键词出现在url中对排名有一定影响，使用inurl:搜索可以更准确地找到竞争对手示例：搜索关于星巴克公司的PDF文档。搜索：inurl:pdf 星巴克 或者inurl:pdf 星巴克 简介 intitle 返回的是页面title 中包含关键词的页面1intitle:“星巴克” Allintitle 搜索返回的是页面标题中包含多组关键词的文件12搜索：allintitle:Starbucks 星巴克就相当于：intitle:Starbucks intitle:星巴克 filetype 用于搜索特定文件格式。12搜索：filetype:pdf Starbucks返回的就是包含Starbucks 这个关键词的所有pdf文件。 一些好玩的1zerg rush # 页面上方降下很多圆圈]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python代码风格和PEP8]]></title>
    <url>%2F2018%2F03%2F31%2Fpython-code-style-pep8%2F</url>
    <content type="text"><![CDATA[变量 常量 : 大写加下划线1USER_CONSTANT 对于不会发生改变的全局变量，使用大写加下划线。 私有变量 : 小写和一个前导下划线1_private_value Python 中不存在私有变量一说，若是遇到需要保护的变量，使用小写和一个前导下划线。但这只是程序员之间的一个约定，用于警告说明这是一个私有变量，外部类不要去访问它。但实际上，外部类还是可以访问到这个变量。 内置变量 : 小写，两个前导下划线和两个后置下划线1__class__ 两个前导下划线会导致变量在解释期间被更名。这是为了避免内置变量和其他变量产生冲突。用户定义的变量要严格避免这种风格。以免导致混乱。 函数和方法总体而言应该使用，小写和下划线。但有些比较老的库使用的是混合大小写，即首单词小写，之后每个单词第一个字母大写，其余小写。但现在，小写和下划线已成为规范。 私有方法 : 小写和一个前导下划线12def _secrete(self): print("Starbucks") 这里和私有变量一样，并不是真正的私有访问权限。同时也应该注意一般函数不要使用两个前导下划线(当遇到两个前导下划线时，Python 的名称改编特性将发挥作用)。 特殊方法 ：小写和两个前导下划线，两个后置下划线12def __add__(self, other): return int.__add__(other) 这种风格只应用于特殊函数，比如操作符重载等。 函数参数 : 小写和下划线，缺省值等号两边无空格12def connect(self, user=None): self._user = user 类类总是使用驼峰格式命名，即所有单词首字母大写其余字母小写。类名应该简明，精确，并足以从中理解类所完成的工作。常见的一个方法是使用表示其类型或者特性的后缀，例如:SQLEngine、MimeTypes。对于基类而言，可以使用一个 Base 或者 Abstract 前缀，例如:BaseCookie、AbstractGroup123456class UserProfile(object): def __init__(self, profile): return self._profile = profile def profile(self): return self._profile 模块和包除特殊模块 __init__ 之外，模块名称都使用不带下划线的小写字母。若是它们实现一个协议，那么通常使用lib为后缀，例如:123import smtplibimport osimport sys 关于参数 不要用断言来实现静态类型检测断言可以用于检查参数，但不应仅仅是进行静态类型检测。Python 是动态类型语言，静态类型检测违背了其设计思想。断言应该用于避免函数不被毫无意义的调用。 不要滥用 *args 和 **kwargs*args 和 **kwargs 参数可能会破坏函数的健壮性。它们使签名变得模糊，而且代码常常开始在不应该的地方构建小的参数解析器。 其他 使用 has 或 is 前缀命名布尔元素 12is_connect = Truehas_member = False 用复数形式命名序列 1members = ['user_1', 'user_2'] 用显式名称命名字典 1person_address = &#123;'user_1':'10 road WD', 'user_2' : '20 street huafu'&#125; 避免通用名称诸如 list, dict, sequence 或者 element 这样的名称应该避免。 避免现有名称诸如 os, sys 这种系统已经存在的名称应该避免。 一些数字 一行列数 : PEP 8 规定为 79 列，这有些苛刻了。根据自己的情况，比如不要超过满屏时编辑器的显示列数。这样就可以在不动水平游标的情况下，方便的查看代码。 一个函数 : 不要超过 30 行代码, 即可显示在一个屏幕类，可以不使用垂直游标即可看到整个函数。 一个类 : 不要超过 200 行代码，不要有超过 10 个方法。 一个模块 不要超过 500 行。]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda]]></title>
    <url>%2F2018%2F03%2F31%2Fpython-anaconda%2F</url>
    <content type="text"><![CDATA[创建一个名为python36的环境，指定Python版本是3.61$ conda create --name python36 python=3.6 # conda会为我们自动寻找3.6.x中的最新版本 安装好后，使用activate激活某个环境12$ activate python36 # for Windows$ source activate python36 # for Linux &amp; Mac 查看当前版本1$ python --version 如果想返回默认的python 2.7环境，运行12$ deactivate python27 # for Windows$ source deactivate python27 # for Linux &amp; Mac 删除一个已有的环境1$ conda remove --name python34 --all 添加Anaconda的TUNA镜像1$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ 设置搜索时显示通道地址1$ conda config --set show_channel_urls yes 查看当前环境下已安装的包1$ conda list 查看某个指定环境的已安装包1$ conda list -n python36 查找package信息1$ conda search numpy 安装package1$ conda install -n python36 numpy # 如果不用-n指定环境名称，则被安装在当前活跃环境 更新package1$ conda update -n python36 numpy 删除package1$ conda remove -n python36 numpy 更新conda，保持conda最新1$ conda update conda 更新anaconda1$ conda update anaconda 更新python1$ conda update python]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[星巴克入门·咖啡篇]]></title>
    <url>%2F2018%2F01%2F30%2Fstarbucks-quickstart-guide-coffee%2F</url>
    <content type="text"><![CDATA[在星巴克常见的几款咖啡有美式咖啡、拿铁咖啡、卡布奇诺、摩卡咖啡、焦糖玛奇朵、馥芮白，通过定制可以做出适合自己口味的咖啡。以下就介绍这几款咖啡的制作和特点。 Espresso 意式浓缩咖啡以7-8公克深度烘焙的综合咖啡豆，研磨成极细的咖啡粉，经过9个大气压与摄氏92度左右的高温热水，在15秒的短时间内急速萃取30毫升的浓烈咖啡液体称之为「Espresso」，也是其他咖啡饮料的基底 Caffè Americano 美式咖啡成分：浓缩咖啡 + 热水,一杯美式咖啡由两份意式浓缩咖啡加30到470ml热水混合而成特点：较好的保留咖啡原有的醇香，提神效果较好Bigger：夏天可以点一杯冰美式，巨苦巨提神，味道不是一般人可接受 Caffè Latte 拿铁咖啡成分：浓缩咖啡 + 牛奶 + 奶泡(较少)特点：无糖，奶泡轻柔。传统的经典饮料，美妙之处也在于它的简单Bigger：Latte Art 「拉花拿铁」，点咖啡时可以要求使用马克杯装，这样咖啡师就会为你拉出不同样式 Cappuccino 卡布奇诺成分：浓缩咖啡 + 牛奶 + 奶泡(较多)特点：与拿铁的区别就在于有一半奶泡，因此口感比拿铁浓郁，奶泡越细腻越好，但是要及时喝完，时间久了奶泡没了比较难喝Bigger：在奶泡上洒上些许肉桂粉、可可粉或是橙橘柠檬类的果皮丝用以装饰或增加风味 Café Mocha 摩卡咖啡成分：浓缩咖啡 + 牛奶 + 巧克力酱 + 鲜奶油(whipped cream)Bigger：White Chocolate Mocha 白巧克力摩卡咖啡，这款饮料特别温暖，适合女生，适合冬季 Caramel Macchiato 焦糖玛奇朵成分：香草糖浆 + 牛奶 + 奶泡 + 浓缩咖啡 + 焦糖糖浆Bigger：推荐搭配 Chocolate Old Fashion（巧克力甜甜圈） Flat White 馥芮白成分：精萃浓缩咖啡（ristretto）+ 牛奶 + 奶泡特点：特有的白点]]></content>
      <categories>
        <category>Starbucksπ</category>
      </categories>
      <tags>
        <tag>星巴克</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[星巴克入门·基础篇]]></title>
    <url>%2F2018%2F01%2F30%2Fstarbucks-quickstart-guide%2F</url>
    <content type="text"><![CDATA[星巴克股份有限公司（英语：Starbucks Corporation，简称：星巴克，英语：Starbucks）是美国一家跨国连锁咖啡店，也是全球最大的连锁咖啡店，发源地与总部位于美国华盛顿州西雅图。除咖啡之外，亦有茶饮等饮料，以及三明治、糕点等点心类食品。其成立于1971年，最初仅专卖咖啡豆，在转型为现行的经营型态后开始快速展店，并成为美式生活的象征之一，部分店铺甚至与超级市场、书店等异业结盟，以复合式商店经营。目前，星巴克已经在中国130个城市开设了2,800家门店，拥有近40,000名身穿绿围裙的星巴克伙伴。 Q&amp;A星巴克有哪些店面类型？ 普通店：只出售以9个大气压冲泡出来的意式浓缩咖啡，及其衍生咖啡及饮品 手冲店：提供高温高压的冲泡方式，也可按客人要求，以手冲壶来冲咖啡 臻选店：提供一般店所没有的臻选咖啡豆供客人选择，臻选店特有「★|R」标志 Q&amp;A星巴克有哪些颜色的围裙？ 「绿色」这是最普遍的围裙颜色，一般兼职员工及正职员工穿的都是绿色围裙，这代表的是他们受过公司的统一训练，能够独自为客人服务 「黑色」穿著黑色围裙的店员被称为「咖啡大师 Coffee Master」，只有通过每年一度「精品咖啡大使」选拔的人才能够穿上，这些店员都具备丰富的咖啡知识，并且能准确调配出客户所点选的咖啡。在臻选店中所有员工都是穿黑色围裙，但是不一定都是Coffee Master 「咖啡色」最稀有的咖啡色围裙则是星巴克在世界各地比赛，选出代表全球的「咖啡大使 Coffee Ambassdor」，他们可说是来自全球各地的星巴克咖啡团队代表 「紫色」2016 年葡萄牙店的助理经理 Fabio da Silva Neno 拿下了星巴克集团举办的 EMEA Barista Championship 的总冠军，因此被加冕「紫色围裙」的殊荣 Q&amp;A星巴克有哪几种杯型？总共有5种，小杯「Short,8oz」，中杯「Tall,12oz」，大杯「Grande 16oz」，超大杯「Venti,20oz」，特大杯「Trenta,30oz」。oz是重量单位盎司，1盎司=28.35g。Short size仅供kid’s drinks和espresso使用，并且没有展示。Trenta size只用于iced coffee &amp; iced tea，这里的”iced coffee”不包括espresso drinks，目前国内似乎没有这个size的杯子。 Q&amp;A星巴克杯子上的英文是什么意思？「Decaf :: 咖啡因」 X : 无咖啡因 1/2 : 一半 「Shots :: 几份espresso」（除了美式以外，其他意式饮料espresso的份量均为：tall(一份浓缩）grand(两份浓缩）venti（两份浓缩）） 1 : 1 Shot 2 : 2 Shots… 「Syrup :: 糖浆」 A : Almond 杏仁 C : Caramel 焦糖 CH : Chai 印度茶 S/CL : Signature/Classic 经典糖浆 CN : Cinnamon 肉桂 H : Hazelnut 榛果 I : Irish Cream 爱尔兰奶油 MO : Mocha Syrup 摩卡糖浆 P : Peppermint 薄荷 R : Raspberry 覆盆子糖浆 SFH : Sugar Free Hazelnut 无糖榛子 SFV : Sugar Free Vanilla 无糖香草 V : Vanilla 香草 WM : White Chocolate Mocha Syrup 白巧克力摩卡糖浆 「Milk :: 牛奶」 B : Breve(half-and-half) 一半奶油一半牛奶 E : Eggnog(seasonal) 蛋酒 % : 50% whole, 50% non-fat 全脂50％，无脂50％ N : Nonfat 脱脂 L : Lowfat 低脂 S : Soy 豆奶 O : Organic Milk 有机牛奶 「Custom :: 定制」 CR : Caramel Sauce 焦糖酱 D : Dry 干 DB|2xB : Double Blended 双混合 F : Foamy 泡沫的 H : Hot 热的 HANDOFF : Deliver to customer’s table 送到客户桌边 K : Kid’s Beverage(tiny size, cooler temperature) 小孩类型的… NW : No Water 不要水 NF : No Foamy 不要奶泡 SL : Sweet’n Low 糖精 SP : Splenda 蔗糖素 STRAB : Strawberry Fruit Sauce 草莓水果酱 SR : Sugar in the raw 原糖 VBEAN : Vanilla Bean Powder 香草豆粉 W : Wet 湿 WC : Whipped Cream 奶油 L : Little 少加 X : Extra 多加 = : Equal 等于 / : Delete 去除 「Drink :: 类型」 A : Caffè Americano 美式咖啡 C : Cappuccino 卡布奇诺 CM : Caramel Macchiato 焦糖玛奇朵 E : Espresso 意式浓缩 L : Caffè Latte 拿铁咖啡 M : Café Mocha 摩卡咖啡 FW : Flat White 馥芮白 F : Frappuccino 星冰乐]]></content>
      <categories>
        <category>Starbucksπ</category>
      </categories>
      <tags>
        <tag>星巴克</tag>
      </tags>
  </entry>
</search>
